# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12l_SjdiVSeXmawuD3K22ho5s84bQn7OJ
"""

# Commented out IPython magic to ensure Python compatibility.
import http.client
import json
import mimetypes
import torch
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
# %matplotlib inline
import torch.nn.functional as F
import torch.nn as nn
from torch import optim
import torchvision.transforms

conn = http.client.HTTPSConnection("api.covid19api.com")
payload = ''
headers = {}
conn.request("GET", "/total/country/india", payload, headers)
res = conn.getresponse()
data = res.read()
data = json.loads(data)
x = data
days = [[float(0)]]
cases = [[float(0)]]
j = 1
for i in range (42, len(data)):
    days.append([float(j)])
    cases.append([float(data[i]['Confirmed'] - data[i-1]['Confirmed'])])
    j = j + 1
scaler = MinMaxScaler(feature_range=(0, 1))
casesout = cases[1:]
casesin = cases[:-1]
print(cases)

torch.manual_seed(1)    

inTensor = torch.tensor(casesin)
outTensor = torch.tensor(casesout)
# view data
plt.figure(figsize=(10,4))
plt.plot(days, cases, color = "red")
plt.title('Regression Analysis')
plt.xlabel('Days')
plt.ylabel('New Cases')
plt.show()

class LSTM(nn.Module):
    def __init__(self, input_size=1, hidden_layer_size=150, output_size=1):
        super().__init__()
        self.hidden_layer_size = hidden_layer_size

        self.lstm = nn.LSTM(input_size, hidden_layer_size)

        self.linear = nn.Linear(hidden_layer_size, output_size)

        self.hidden_cell = (torch.zeros(1,1,self.hidden_layer_size),
                            torch.zeros(1,1,self.hidden_layer_size))
  

    def forward(self, input_seq):
        lstm_out, self.hidden_cell = self.lstm(input_seq.view(len(input_seq) ,1, -1), self.hidden_cell)
        predictions = self.linear(lstm_out.view(len(input_seq), -1))
        return predictions[-1]
    

model = LSTM()
loss_function = nn.MSELoss()
optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.01)
print(model)

epochs = 1500
l = []
for i in range(epochs):
    ypl = []
    for inp, outp in zip(inTensor, outTensor):
        optimizer.zero_grad()
        model.hidden_cell = (torch.zeros(1, 1, model.hidden_layer_size),
                        torch.zeros(1, 1, model.hidden_layer_size))

        y_pred = model(inp)
        ypl.append(y_pred)
        loss = loss_function(y_pred, outp)
        loss.backward()
        optimizer.step()
        
    if i%25 == 1:
        print(f'epoch: {i:3} loss: {loss.item():10.8f}')
        l.append(loss.item())
        plt.plot(days[:-1], ypl, color = "red")
        plt.plot(days, cases, color = "green")
        plt.figure(figsize=(10,4))
        plt.show()

plt.plot(l, color = "red")
plt.figure(figsize=(10,4))
plt.show()
print(f'epoch: {i:3} loss: {loss.item():10.10f}')

fig = plt.figure()
ax = plt.subplot(111)
ax.plot(days, cases, color = "red", label = 'original')
ax.plot(days[:-1], ypl, color = "green", label = 'predicted')
plt.title('Legend inside')
ax.legend()
plt.show()

print(model(torch.tensor([10438.0])))